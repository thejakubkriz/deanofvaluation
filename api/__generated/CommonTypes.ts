
/**
 * 
 * This 'ImplementationType' is used for inheritance, let's see an example, if graphql schema is:
 * 
 *     interface A {}
 *     interface B implements A {}
 *     type C implements B & A {}
 * 
 * Typescript code will be generated by like this:
 * 
 *     export ImplementationType<T extends string> =
 *         T extends 'A' ? 'A' | ImplementationType<'B'> :
 *         T extends 'B' ? 'B' | ImplementationType<'C'> :
 *         T
 *     ;
 * 
 * Let's see another example with abstract type, if the graphql schema is:
 * 
 *     union AbstractType = Impl1 | Imple2;
 *     type Impl1 {}
 *     type Impl2 {}
 * 
 * Typescript code will be generated by like this:
 * 
 *     export ImplementationType<T extends string> =
 *         T extends 'AbstractType' ? ImplemenationType<'Impl1'> | ImplementationType<'Impl2'> :
 *         T
 *     ;
 */
export type ImplementationType<T> = 
    T extends '_Field' ? '_Field' | ImplementationType<'_Column'> | ImplementationType<'_Relation'> :
    T extends '_Argument' ? ImplementationType<'_ValidatorArgument'> | ImplementationType<'_PathArgument'> | ImplementationType<'_LiteralArgument'> :
    T
;
/**
 * 
 * This 'upcastTypes' is used for inheritance, let's see an example, if graphql schema is:
 * 
 *     interface A {}
 *     interface B implements A {}
 *     type C implements B & A {}
 * 
 * Typescript code will be generated by like this:
 * 
 *     export function upcastTypes(typeName: string): string[] {
 *         const typeNames: string[] = [];
 *         upcastTypes0(typeName, typeNames);
 *         return typeNames;
 *     }
 * 
 *     function upcastTypes0(typeName: string, output: string[]) {
 *         switch (typeName){
 *             case 'B':
 *                 output.push('B');
 *                 upcastTypes0('A', output);
 *                 break;
 *             case 'C':
 *                 output.push('C');
 *                 upcastTypes0('B', output);
 *                 break;
 *             default:
 *                 output.push(typeName);
 *                 break;
 *         }
 *     }    
 * 
 * Let's see another example with abstract type, if the graphql schema is:
 * 
 *     union AbstractType = Impl1 | Imple2;
 *     type Impl1 {}
 *     type Impl2 {}
 * 
 * Typescript code will be generated by like this:
 * 
 *     export function upcastTypes(typeName: string): string[] {
 *         const typeNames: string[] = [];
 *         upcastTypes0(typeName, typeNames);
 *         return typeNames;
 *     }
 * 
 *     function upcastTypes0(typeName: string, output: string[]) {
 *         switch (typeName){
 *             case 'Impl1':
 *                 output.push('Impl1');
 *                 upcastTypes0('AbstractType', output);
 *                 break;
 *             case 'Impl2':
 *                 output.push('Impl2');
 *                 upcastTypes0('AbstractType', output);
 *                 break;
 *             default:
 *                 output.push(typeName);
 *                 break;
 *         }
 *     }     
 */

export function upcastTypes(typeName: string): string[] {
    const typeNames: string[] = [];
    upcastTypes0(typeName, typeNames);
    return typeNames;
}

function upcastTypes0(typeName: string, output: string[]) {
    switch (typeName){
        case '_Column':
            output.push('_Column');
            upcastTypes0('_Field', output);
            break;
        case '_Relation':
            output.push('_Relation');
            upcastTypes0('_Field', output);
            break;
        case '_ValidatorArgument':
            output.push('_ValidatorArgument');
            upcastTypes0('_Argument', output);
            break;
        case '_PathArgument':
            output.push('_PathArgument');
            upcastTypes0('_Argument', output);
            break;
        case '_LiteralArgument':
            output.push('_LiteralArgument');
            upcastTypes0('_Argument', output);
            break;
        default:
            output.push(typeName);
            break;
    }
}

/**
 * 
 * This 'downcastTypes' is used for inheritance, let's see an example, if graphql schema is:
 * 
 *     interface A {}
 *     interface B implements A {}
 *     type C implements B & A {}
 * 
 * Typescript code will be generated by like this:
 * 
 *     export function downcastTypes(typeName: string): string[] {
 *         const typeNames: string[] = [];
 *         downcastTypes0(typeName, typeNames);
 *         return typeNames;
 *     }
 * 
 *     function downcastTypes0(typeName: string, output: string[]) {
 *         switch (typeName){
 *             case 'A':
 *                 output.push('A');
 *                 downcastTypes0('B', output);
 *                 break;
 *             case 'B':
 *                 output.push('B');
 *                 downcastTypes0('C', output);
 *                 break;
 *             default:
 *                 output.push(typeName);
 *                 break;
 *         }
 *     }
 * 
 * Let's see another example with abstract type, if the graphql schema is:
 * 
 *     union AbstractType = Impl1 | Imple2;
 *     type Impl1 {}
 *     type Impl2 {}
 * 
 * Typescript code will be generated by like this:
 * 
 *     export function downcastTypes(typeName: string): string[] {
 *         const typeNames: string[] = [];
 *         downcastTypes0(typeName, typeNames);
 *         return typeNames;
 *     }
 * 
 *     function downcastTypes0(typeName: string, output: string[]) {
 *         switch (typeName){
 *             case 'AbstractType':
 *                 downcastTypes0('Impl1', output);
 *                 downcastTypes0('Impl2', output);
 *                 break;
 *             default:
 *                 output.push(typeName);
 *                 break;
 *         }
 *     }   
 */

export function downcastTypes(typeName: string): string[] {
    const typeNames: string[] = [];
    downcastTypes0(typeName, typeNames);
    return typeNames;
}

function downcastTypes0(typeName: string, output: string[]) {
    switch (typeName){
        case '_Field':
            output.push('_Field');
            downcastTypes0('_Column', output);
            downcastTypes0('_Relation', output);
            break;
        case '_Argument':
            downcastTypes0('_ValidatorArgument', output);
            downcastTypes0('_PathArgument', output);
            downcastTypes0('_LiteralArgument', output);
            break;
        default:
            output.push(typeName);
            break;
    }
}

export type WithTypeName<T, TypeName extends string> =
    T extends {readonly __typename: string} ?
    T :
    T & {readonly __typename: TypeName};
;

